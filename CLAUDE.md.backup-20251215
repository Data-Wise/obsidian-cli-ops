# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Obsidian CLI Ops (obs)** is an intelligent command-line tool for managing multi-vault Obsidian systems with knowledge graph analysis and R development integration.

**Current Version**: 2.0.0-beta

### What It Does

- **v1.x Features**: Federated vault management, plugin installation, R-Dev integration
- **v2.0 Features**: Knowledge graph analysis, vault scanning, link resolution, graph metrics, AI-powered similarity detection (100% free, local, private)

### Technology Stack

- **ZSH**: Main CLI interface (`src/obs.zsh`)
- **Python**: Backend for v2.0 features (`src/python/`)
- **SQLite**: Knowledge graph database (`~/.config/obs/vault_db.sqlite`)
- **NetworkX**: Graph analysis library
- **HuggingFace/Ollama**: Free local AI (embeddings, similarity detection)
- **Node.js**: Testing harness (Jest)
- **MkDocs**: Documentation site

## Core Architecture

### Three-Layer Design

Obsidian CLI Ops follows a clean three-layer architecture that separates presentation, business logic, and data access. This design enables multiple interfaces (CLI, TUI, GUI) to share the same core logic without duplication.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         PRESENTATION LAYER                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   CLI    â”‚  â”‚   TUI    â”‚  â”‚   GUI    â”‚     â”‚
â”‚  â”‚(obs_cli) â”‚  â”‚(Textual) â”‚  â”‚ (Future) â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         APPLICATION LAYER (CORE)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  VaultManager                        â”‚    â”‚
â”‚  â”‚  - discover_vaults()                 â”‚    â”‚
â”‚  â”‚  - scan_vault()                      â”‚    â”‚
â”‚  â”‚  - list_vaults()                     â”‚    â”‚
â”‚  â”‚  - get_vault_stats()                 â”‚    â”‚
â”‚  â”‚                                      â”‚    â”‚
â”‚  â”‚  GraphAnalyzer                       â”‚    â”‚
â”‚  â”‚  - analyze_vault()                   â”‚    â”‚
â”‚  â”‚  - calculate_metrics()               â”‚    â”‚
â”‚  â”‚  - find_clusters()                   â”‚    â”‚
â”‚  â”‚  - get_hub_notes()                   â”‚    â”‚
â”‚  â”‚                                      â”‚    â”‚
â”‚  â”‚  Domain Models                       â”‚    â”‚
â”‚  â”‚  - Vault, Note, ScanResult          â”‚    â”‚
â”‚  â”‚  - GraphMetrics, VaultStats          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         DATA LAYER                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  DatabaseManager                     â”‚    â”‚
â”‚  â”‚  VaultScanner                        â”‚    â”‚
â”‚  â”‚  GraphBuilder                        â”‚    â”‚
â”‚  â”‚  MarkdownParser                      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Layer 1: Presentation (Interfaces)
**Location:** `src/obs.zsh`, `src/python/obs_cli.py`, `src/python/tui/`

- **ZSH CLI** (`src/obs.zsh`): Shell integration, v1.x commands, wrapper for Python CLI
- **Python CLI** (`src/python/obs_cli.py`): Argparse-based CLI for v2.0 commands
- **TUI** (`src/python/tui/`): Textual-based interactive interface
- **GUI** (planned): Future graphical interface

**Responsibilities:**
- Handle user input (keyboard, mouse, CLI arguments)
- Format output for specific interface (text, colors, widgets)
- No business logic - just presentation
- Call application layer methods
- Display errors and results

#### Layer 2: Application (Core Business Logic)
**Location:** `src/python/core/`

**VaultManager** (`vault_manager.py`, 311 lines):
- Vault discovery and validation
- Scanning orchestration
- Vault CRUD operations
- Statistics aggregation
- Interface-agnostic business logic

**GraphAnalyzer** (`graph_analyzer.py`, 311 lines):
- Graph analysis orchestration
- Metrics calculation
- Hub/orphan detection
- Cluster finding
- Link resolution

**Domain Models** (`models.py`, 237 lines):
- `Vault`: Vault metadata
- `Note`: Note content and metadata
- `ScanResult`: Scan operation results
- `GraphMetrics`: Graph analysis metrics
- `VaultStats`: Statistical summaries

**Custom Exceptions** (`exceptions.py`):
- `VaultNotFoundError`
- `ScanError`
- `AnalysisError`

**Responsibilities:**
- All business logic lives here
- Interface-agnostic (works with CLI, TUI, GUI)
- Returns structured data (not formatted strings)
- Raises domain-specific exceptions
- Orchestrates data layer operations

#### Layer 3: Data (Persistence & I/O)
**Location:** `src/python/` (db_manager.py, vault_scanner.py, etc.)

- **DatabaseManager**: SQLite operations
- **VaultScanner**: File system scanning
- **GraphBuilder**: NetworkX graph construction
- **MarkdownParser**: Markdown parsing
- **AI Clients**: Embeddings and similarity

**Responsibilities:**
- Database queries and updates
- File system I/O
- External API calls
- No business logic
- Returns raw data

### Benefits of Three-Layer Architecture

1. **Code Reusability**: CLI and TUI share 100% of business logic
2. **Easy Testing**: Core layer can be tested independently
3. **Flexible Interfaces**: Add GUI without changing business logic
4. **Clear Separation**: Each layer has single responsibility
5. **Type Safety**: Domain models provide type checking
6. **Maintainability**: Changes in one layer don't affect others

### Main Script: `src/obs.zsh`

The script is designed as a ZSH function library that can be:
- Sourced and called as a function (`obs <command>`)
- Executed directly as a standalone script

**Key architectural components:**

1. **Configuration System**:
   - User config: `~/.config/obs/config` (defines `OBS_ROOT` and `VAULTS` array)
   - Project mapping: `~/.config/obs/project_map.json` (maps R project paths to Obsidian folders)
   - Database: `~/.config/obs/vault_db.sqlite` (knowledge graph storage)
   - AI config: `~/.config/obs/ai_config.json` (AI provider and model settings)

2. **Command Routing**:
   - Commands that don't need config: `help`, `version`, `check`, `discover`, `analyze`, `vaults`, `stats`, `ai`
   - Commands that need config: `list`, `sync`, `install`, `search`, `audit`, `r-dev`

3. **Helper Functions**:
   - `_get_r_root()`: Climbs directory tree to find R project root
   - `_get_mapped_path()`: Looks up Obsidian path for current R project
   - `_get_plugin_url()`: Searches Obsidian plugin registry
   - `_get_python_cli()`: Locates Python CLI for v2.0 commands

### Python Module: `src/python/`

**Module Structure:**

```
src/python/
â”œâ”€â”€ __init__.py                # Package initialization
â”‚
â”œâ”€â”€ core/                      # APPLICATION LAYER (859 lines)
â”‚   â”œâ”€â”€ __init__.py            # Core package initialization
â”‚   â”œâ”€â”€ vault_manager.py       # Vault business logic (311 lines)
â”‚   â”œâ”€â”€ graph_analyzer.py      # Graph business logic (311 lines)
â”‚   â”œâ”€â”€ models.py              # Domain models (237 lines)
â”‚   â””â”€â”€ exceptions.py          # Custom exceptions
â”‚
â”œâ”€â”€ tui/                       # PRESENTATION LAYER - TUI (1,701 lines)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py                 # Main TUI application (282 lines)
â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ vaults.py          # Vault browser (267 lines)
â”‚   â”‚   â”œâ”€â”€ notes.py           # Note explorer (378 lines)
â”‚   â”‚   â”œâ”€â”€ graph.py           # Graph visualizer (378 lines)
â”‚   â”‚   â””â”€â”€ stats.py           # Statistics dashboard (420 lines)
â”‚   â””â”€â”€ widgets/
â”‚       â””â”€â”€ __init__.py
â”‚
â”œâ”€â”€ obs_cli.py                 # PRESENTATION LAYER - CLI (318 lines)
â”‚
â”œâ”€â”€ db_manager.py              # DATA LAYER - Database (469 lines)
â”œâ”€â”€ vault_scanner.py           # DATA LAYER - File scanning (373 lines)
â”œâ”€â”€ graph_builder.py           # DATA LAYER - Graph construction (307 lines)
â”‚
â”œâ”€â”€ ai_client.py               # AI client base & factory (440 lines)
â”œâ”€â”€ ai_client_ollama.py        # Ollama integration (450 lines)
â”œâ”€â”€ ai_client_hf.py            # HuggingFace integration (340 lines)
â”œâ”€â”€ setup_wizard.py            # Interactive AI setup (837 lines)
â”œâ”€â”€ similarity_analyzer.py     # Note similarity analysis (470 lines)
â”‚
â”œâ”€â”€ requirements.txt           # Python dependencies
â””â”€â”€ README.md                  # Python module documentation
```

**Key Classes:**

### Core Layer (Application)

1. **VaultManager** (`core/vault_manager.py`, 311 lines):
   - **Purpose:** Orchestrates vault operations (interface-agnostic)
   - `discover_vaults(root_path)`: Find Obsidian vaults in directory tree
   - `list_vaults()`: Get all registered vaults
   - `get_vault(vault_id)`: Get vault by ID
   - `scan_vault(path, name, force)`: Scan vault and return ScanResult
   - `get_vault_stats(vault_id)`: Get statistical summary
   - `get_notes(vault_id, limit, offset)`: Get notes from vault
   - `search_notes(vault_id, query)`: Search notes by title/content
   - `delete_vault(vault_id)`: Remove vault from database
   - **Used by:** CLI, TUI, future GUI

2. **GraphAnalyzer** (`core/graph_analyzer.py`, 311 lines):
   - **Purpose:** Orchestrates graph analysis operations
   - `analyze_vault(vault_id)`: Complete graph analysis pipeline
   - `get_graph(vault_id)`: Build NetworkX graph
   - `get_note_metrics(note_id)`: Get graph metrics for note
   - `get_hub_notes(vault_id)`: Get highly connected notes
   - `get_orphan_notes(vault_id)`: Get isolated notes
   - `get_broken_links(vault_id)`: Get unresolved wikilinks
   - `calculate_metrics(vault_id)`: Calculate PageRank, centrality
   - `resolve_links(vault_id)`: Resolve wikilinks to note IDs
   - `find_clusters(vault_id)`: Detect communities in graph
   - `get_ego_graph(note_id, radius)`: Get local neighborhood
   - **Used by:** CLI, TUI, future GUI

3. **Domain Models** (`core/models.py`, 237 lines):
   - **Vault:** Vault metadata (id, name, path, counts, timestamps)
   - **Note:** Note content and metadata (title, path, word_count, tags, links)
   - **ScanResult:** Scan operation results (notes scanned, links found, duration, errors)
   - **GraphMetrics:** Graph analysis metrics (PageRank, centrality, clustering)
   - **VaultStats:** Statistical summaries (totals, averages, graph density)
   - All models have `from_db_row()`, `to_dict()`, `to_json()` methods

4. **Custom Exceptions** (`core/exceptions.py`):
   - **VaultNotFoundError:** Vault doesn't exist or path invalid
   - **ScanError:** Scan operation failed
   - **AnalysisError:** Graph analysis failed

### Data Layer

5. **DatabaseManager** (`db_manager.py`, 469 lines):
   - `get_connection()`: Context manager for DB connections
   - `add_vault()`, `get_vault()`, `list_vaults()`: Vault operations
   - `add_note()`, `get_note()`, `list_notes()`: Note operations
   - `add_link()`, `get_outgoing_links()`, `get_incoming_links()`: Link operations
   - `add_tag()`, `get_note_tags()`, `get_tag_stats()`: Tag operations
   - `get_orphaned_notes()`, `get_hub_notes()`, `get_broken_links()`: Graph queries

6. **VaultScanner** (`vault_scanner.py`, 373 lines):
   - `discover_vaults()`: Finds vaults by `.obsidian` directory
   - `scan_vault()`: Parses all markdown files and populates database
   - **MarkdownParser**: Extracts frontmatter, wikilinks, tags, metadata

7. **GraphBuilder** (`graph_builder.py`, 307 lines):
   - **LinkResolver**: Resolves wikilinks to note IDs
   - `build_graph()`: Constructs NetworkX directed graph
   - `calculate_metrics()`: PageRank, centrality, clustering
   - `find_clusters()`: Community detection
   - `analyze_vault()`: Complete analysis pipeline

### Presentation Layer

8. **ObsCLI** (`obs_cli.py`, 318 lines):
   - Argparse-based CLI interface
   - Commands: discover, scan, analyze, stats, vaults, db, ai
   - **Now uses VaultManager and GraphAnalyzer** for business logic
   - Verbose mode support

9. **TUI Application** (`tui/app.py`, 282 lines):
   - Textual-based interactive interface
   - Screens: Home, Vaults, Notes, Graph, Stats, Help
   - **Uses VaultManager and GraphAnalyzer** for all data operations
   - Keyboard navigation with vim keys

### AI Layer

10. **AI Clients** (`ai_client.py`, `ai_client_ollama.py`, `ai_client_hf.py`):
   - **AIClient**: Abstract base class for AI providers
   - **OllamaClient**: Local Ollama integration (embeddings + reasoning)
   - **HuggingFaceClient**: sentence-transformers integration (embeddings)
   - **get_ai_client()**: Factory function for provider selection
   - Support for multiple models (qwen2.5:0.5b, llama3.1, all-mpnet-base-v2, etc.)

11. **AISetupWizard** (`setup_wizard.py`, 837 lines):
   - Interactive setup with two paths (Quick Start, Custom)
   - System auto-detection (OS, Python, RAM, Ollama)
   - Provider and model selection menus
   - Automatic installation and testing
   - Config persistence to `~/.config/obs/ai_config.json`
   - Progress bars with `rich` library

12. **SimilarityAnalyzer** (`similarity_analyzer.py`, 470 lines):
   - Find similar notes using embeddings
   - Duplicate detection with threshold
   - Topic analysis and clustering
   - Merge suggestions with reasoning

### Database Schema: `schema/vault_db.sql`

**Tables:**
- `vaults`: Vault metadata
- `notes`: Note content, metadata, hashes
- `links`: Wikilink relationships (source â†’ target)
- `tags`: Tag definitions
- `note_tags`: Many-to-many tag-note relationships
- `graph_metrics`: PageRank, centrality, clustering
- `scan_history`: Scan tracking and analytics

**Views:**
- `orphaned_notes`: Notes with no incoming/outgoing links
- `hub_notes`: Highly connected notes (>10 links)
- `broken_links`: Unresolved wikilinks

**Triggers:**
- Auto-update vault note counts
- Auto-update tag counts
- Auto-update graph in/out degrees

### R-Dev Integration Flow

The R-Dev module requires a two-step workflow:
1. **Link**: Establish mapping between R project and Obsidian folder (`obs r-dev link`)
2. **Operations**: Once linked, use `log`, `draft` commands which auto-detect context

This design allows users to work within their R project directory without specifying the Obsidian target repeatedly.

## Development Commands

### Python Dependencies

```bash
# Install required packages (Phase 1)
pip3 install python-frontmatter mistune PyYAML networkx

# Install AI packages (Phase 2)
# Option 1: HuggingFace (recommended, free forever)
pip3 install sentence-transformers numpy scikit-learn rich

# Option 2: Ollama (requires Ollama installed)
brew install ollama
pip3 install requests numpy rich

# Optional: Run interactive setup wizard
obs ai setup --quick

# Optional paid APIs (commented out in requirements.txt)
# pip3 install anthropic google-generativeai
```

### Testing

```bash
# Run Node.js test harness (Jest)
npm test

# Run shell integration tests for R-Dev module
bash tests/test_r_dev.sh

# Test Python CLI directly
python3 src/python/obs_cli.py --help
python3 src/python/obs_cli.py db init
python3 src/python/obs_cli.py stats

# Test individual Python modules
python3 src/python/db_manager.py
python3 src/python/vault_scanner.py /path/to/vault
python3 src/python/graph_builder.py <vault_id>
```

### Linting and Formatting

```bash
# Lint
npm run lint

# Format all files
npm run format

# Check formatting without modifying
npx prettier --check .
```

### Documentation

```bash
# Serve docs locally
mkdocs serve

# Build docs
mkdocs build

# Deploy to GitHub Pages (automatic on push to main)
mkdocs gh-deploy --force
```

Docs are in `docs_mkdocs/` and deployed via GitHub Actions to GitHub Pages.

## Configuration Files

### `.eslintrc.js`
- Configured for Node.js and Jest environment
- Prettier integration for consistent style
- `no-console` rule disabled (CLI tool needs console output)

### `.prettierrc`
- Semicolons enabled
- Single quotes
- 2-space indentation
- ES5 trailing commas

### `jest.config.js`
- Node environment
- Matches test files: `**/*.test.js`, `**/*.spec.js`

### `mkdocs.yml`
- Material theme with custom colors
- Code highlighting for multiple languages
- GitHub repository integration

## Key Implementation Details

### Plugin Installation (v1.x)
Uses GitHub API to fetch latest release assets from Obsidian community plugins. Downloads `main.js`, `manifest.json`, and `styles.css` to vault's `.obsidian/plugins/<id>/` directory.

### Vault Sync (v1.x)
Syncs `appearance.json`, `hotkeys.json`, `themes/`, and `snippets/` from root vault (`.obsidian/`) to all sub-vaults defined in `VAULTS` array.

### R-Dev Artifact Logging (v1.x)
Copies files to `06_Analysis` with timestamp prefix format: `YYYYMMDD_HHMMSS_<original_filename>`. This prevents overwrites and maintains chronological organization.

### Vault Scanning (v2.0)
1. Discovers vaults by searching for `.obsidian` directories
2. Parses markdown files with `python-frontmatter` library
3. Extracts wikilinks using regex: `\[\[([^\]|]+)(?:\|([^\]]+))?\]\]`
4. Extracts tags using regex: `#([a-zA-Z0-9_/-]+)`
5. Stores content hash (SHA256) for change detection
6. Populates database with notes, links, tags

### Link Resolution (v2.0)
1. Builds cache of note paths, titles, and aliases
2. Resolves wikilinks by trying multiple strategies:
   - Exact path match
   - Path without `.md` extension
   - Relative path from source note
   - Filename only match
3. Updates links table with resolved `target_note_id`
4. Marks unresolved links as `broken`

### Graph Analysis (v2.0)
1. Constructs NetworkX `DiGraph` from database links
2. Calculates metrics:
   - **PageRank**: Importance score based on link structure
   - **In/Out Degree**: Number of incoming/outgoing links
   - **Betweenness Centrality**: How often note is on path between others
   - **Closeness Centrality**: Average distance to all other notes
   - **Clustering Coefficient**: How connected note's neighbors are
3. Updates `graph_metrics` table
4. Identifies special notes (orphans, hubs)

### How CLI and TUI Share Core Logic

The three-layer architecture enables CLI and TUI to share 100% of business logic. Here's how:

```python
# Core layer (interface-agnostic business logic)
from core.vault_manager import VaultManager

vault_manager = VaultManager()
result = vault_manager.scan_vault("/path/to/vault")
```

```python
# CLI implementation (formats result as text)
def scan_command(args):
    vault_manager = VaultManager()
    result = vault_manager.scan_vault(args.path)

    # CLI-specific formatting
    print(f"âœ“ Scanned {result.notes_scanned} notes")
    print(f"âœ“ Found {result.links_found} links")
    print(f"âœ“ Took {result.duration_seconds:.2f}s")
```

```python
# TUI implementation (displays result in widgets)
class VaultBrowserScreen(Screen):
    def on_scan_clicked(self):
        vault_manager = VaultManager()
        result = vault_manager.scan_vault(self.vault_path)

        # TUI-specific display
        self.update_status_label(
            f"Scanned {result.notes_scanned} notes in {result.duration_seconds:.2f}s"
        )
        self.refresh_vault_list()
```

**Key points:**
- Same `vault_manager.scan_vault()` call in both
- Same `result` object with structured data
- Different presentation: CLI prints text, TUI updates widgets
- Zero business logic duplication

**Example 2: Listing vaults**

```python
# Core layer
vaults = vault_manager.list_vaults()  # Returns List[Vault]

# CLI: Print as table
for vault in vaults:
    print(f"{vault.id:8} {vault.name:20} {vault.note_count:5} notes")

# TUI: Display in DataTable widget
table.add_rows([
    [vault.id, vault.name, str(vault.note_count)]
    for vault in vaults
])
```

**Example 3: Graph analysis**

```python
# Core layer
from core.graph_analyzer import GraphAnalyzer

graph_analyzer = GraphAnalyzer()
result = graph_analyzer.analyze_vault(vault_id)

# CLI: JSON output
if args.json:
    print(json.dumps(result, indent=2))
else:
    print(f"Resolved {result['links_resolved']} links")
    print(f"Found {result['clusters_found']} clusters")

# TUI: Interactive visualization
self.show_graph_metrics(result)
self.display_clusters(result['clusters_found'])
```

### Adding a New Interface (GUI Example)

Because business logic is in the core layer, adding a GUI is straightforward:

```python
# gui/main_window.py (Future)
from PySide6.QtWidgets import QMainWindow, QPushButton
from core.vault_manager import VaultManager

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.vault_manager = VaultManager()  # Same core logic!

    def on_scan_clicked(self):
        result = self.vault_manager.scan_vault(self.vault_path)

        # GUI-specific display
        QMessageBox.information(
            self,
            "Scan Complete",
            f"Scanned {result.notes_scanned} notes\n"
            f"Found {result.links_found} links"
        )
```

**No changes needed to VaultManager!** Just create new presentation layer.

## v2.0 Command Reference

### Vault Discovery and Scanning

```bash
# Discover vaults in directory
obs discover ~/Documents -v

# Discover and scan automatically
obs discover ~/Documents --scan -v

# Scan specific vault
python3 src/python/obs_cli.py scan /path/to/vault --analyze -v
```

### Graph Analysis

```bash
# List all vaults (get vault IDs)
obs vaults

# Analyze vault graph
obs analyze <vault_id> -v

# View statistics
obs stats                    # Global stats
obs stats <vault_id>         # Vault-specific stats
```

### Database Management

```bash
# Initialize/rebuild database
python3 src/python/obs_cli.py db init

# View database stats
python3 src/python/obs_cli.py db stats
```

### AI Setup and Configuration

```bash
# Interactive setup wizard (recommended)
obs ai setup

# Quick start (auto-detect and install)
obs ai setup --quick

# View current configuration
obs ai config

# Test AI clients directly (Python)
python3 src/python/ai_client_ollama.py
python3 src/python/ai_client_hf.py

# Run setup wizard directly
python3 src/python/setup_wizard.py --quick
```

## Testing Strategy

### Node.js Tests (Jest)
- Help command output validation
- Error handling for missing config
- Verbose mode functionality
- Config file validation
- Script structure verification

### Shell Tests (Bash)
- Project linking creates proper JSON mapping entries
- Artifact logging copies files with timestamps
- Context search finds Knowledge Base content
- Draft sync copies files to correct Obsidian folders

### Python Module Tests (Future)
- Database operations
- Markdown parsing accuracy
- Link resolution correctness
- Graph metric calculations

## Project Roadmap

### Phase 1: Foundation âœ… COMPLETE
- Database schema and manager
- Vault scanner with markdown parsing
- Graph builder with NetworkX
- CLI integration

### Phase 2: AI Integration âœ… COMPLETE
- **FREE local AI providers** (HuggingFace + Ollama)
- Interactive setup wizard with auto-detection
- Embedding generation (384-1024 dimensions)
- Note comparison using cosine similarity
- **Privacy-first**: 100% free, 100% local, 100% private
- Multi-provider architecture (easy to add more)
- **Documentation**: Complete setup guide with troubleshooting

### Phase 3: TUI/Visualization ğŸš§ IN PROGRESS
**Priority:** HIGH (moved ahead of Phase 4)
**Started:** 2025-12-13
**Plan:** See PHASE_4_TUI_PLAN.md

**Features:**
- Interactive vault browser (using Textual framework)
- Note explorer with search/preview
- Graph visualization (ASCII art)
- Statistics dashboard
- Keyboard navigation (arrows, vim keys, mouse)
- ADHD-friendly design (colors, emojis, clear hierarchy)

**Commands:**
- `obs tui` - Launch TUI application
- `obs tui --vault-id <id>` - Open specific vault
- `obs tui --screen <name>` - Open specific screen

**Rationale:**
- Can visualize existing Phase 1 data immediately
- Better UX for vault exploration
- Foundation ready when Phase 4 features arrive
- Standalone utility value

### Phase 4: AI-Powered Features (Deferred)
**Status:** Deferred (Phase 3 prioritized)
**Will integrate with:** Phase 3 TUI when complete

**Features:**
- Find similar notes (`obs ai similar`)
- Detect duplicates (`obs ai duplicates`)
- Topic analysis and clustering (`obs ai topics`)
- Merge suggestions with reasoning
- Single note analysis
- TUI review interface for suggestions

### Phase 5: Learning System (Planned)
- User feedback collection
- Rule generation
- Accuracy improvement
- Personalized suggestions

### Phase 6: Automation (Planned)
- Automated vault watching
- Scheduled scans
- Automatic AI-powered suggestions
- Background processing

## Important Files

### Documentation
- `PROJECT_HUB.md`: ADHD-friendly control center
- `PROJECT_PLAN_v2.0.md`: Complete 12-week roadmap (phase reordering: TUI before AI features)
- `.STATUS`: Comprehensive project status and metrics
- `V2_QUICKSTART.md`: Quick start guide for v2.0
- `PHASE_1_COMPLETE.md`: Phase 1 summary and usage
- `PHASE_2_COMPLETE.md`: Phase 2 AI integration summary
- `PHASE_4_TUI_PLAN.md`: Phase 3 TUI implementation plan (452 lines)
- `AI_SETUP_QUICKSTART.md`: One-page AI setup guide
- `docs_mkdocs/ai-setup.md`: Complete AI setup documentation (741 lines)
- `TEST_SUITE_SUMMARY.md`: Test suite documentation (162+ tests)
- `src/python/README.md`: Python module documentation

### Examples
- `config/example.project_map.json`: R project mapping template

### Schema
- `schema/vault_db.sql`: Complete database schema with comments

## Common Workflows

### Adding a New v2.0 Command (Three-Layer Approach)

**Step 1: Add business logic to core layer**

```python
# src/python/core/vault_manager.py
def export_vault(self, vault_id: str, format: str) -> ExportResult:
    """Export vault to specific format."""
    vault = self.get_vault(vault_id)
    if not vault:
        raise VaultNotFoundError(f"Vault not found: {vault_id}")

    # Business logic here (interface-agnostic)
    notes = self.get_notes(vault_id)
    # ... export logic ...

    return ExportResult(
        vault_id=vault_id,
        format=format,
        notes_exported=len(notes),
        output_path=output_path
    )
```

**Step 2: Add CLI interface**

```python
# src/python/obs_cli.py
def export(self, args):
    """Export vault command."""
    result = self.vault_manager.export_vault(args.vault_id, args.format)

    # CLI-specific formatting
    if args.json:
        print(result.to_json())
    else:
        print(f"âœ“ Exported {result.notes_exported} notes to {result.output_path}")
```

**Step 3: Add argument parser**

```python
# src/python/obs_cli.py main()
export_parser = subparsers.add_parser('export', help='Export vault')
export_parser.add_argument('vault_id', help='Vault ID')
export_parser.add_argument('--format', choices=['json', 'csv', 'html'], default='json')
```

**Step 4: Add TUI interface (optional)**

```python
# src/python/tui/screens/vaults.py
def on_export_clicked(self):
    """Handle export button click."""
    result = self.vault_manager.export_vault(self.selected_vault_id, "json")

    # TUI-specific display
    self.notify(f"Exported {result.notes_exported} notes")
    self.refresh()
```

**Step 5: Add ZSH wrapper**

```zsh
# src/obs.zsh
obs_export() {
    local python_cli=$(_get_python_cli) || return 1
    python3 "$python_cli" export "$@"
}
```

**Key principles:**
- Business logic in core layer (step 1)
- Presentation logic in CLI/TUI (steps 2, 4)
- Both interfaces use same core method
- Zero duplication of business logic

### Extending the Database

1. Update `schema/vault_db.sql` with new table/column
2. Increment version in `schema_version` table
3. Add corresponding methods to `DatabaseManager`
4. Update views/triggers if needed
5. Test with `python3 src/python/db_manager.py`

### Adding New Graph Metrics

1. Add calculation in `GraphBuilder.calculate_metrics()`
2. Update `graph_metrics` table schema if needed
3. Add query method in `DatabaseManager`
4. Expose in CLI commands

## Dependencies and Requirements

### System Requirements
- macOS, Linux, or WSL2
- ZSH shell
- Python 3.9+
- Node.js 18+ (for testing)

### Required CLI Tools
- `curl`: API requests
- `jq`: JSON parsing
- `unzip`: Plugin extraction
- `git`: Version control

### Python Packages
- `python-frontmatter`: YAML frontmatter parsing
- `mistune`: Markdown rendering
- `PyYAML`: YAML parsing
- `networkx`: Graph analysis

### AI Packages (Phase 2)
- `sentence-transformers`: HuggingFace embeddings (recommended, free)
- `requests`: Ollama API client
- `numpy`: Numerical operations
- `scikit-learn`: Clustering and similarity
- `rich`: Terminal UI for setup wizard

### Optional Python Packages
- `anthropic`: Claude API (paid, commented out)
- `google-generativeai`: Gemini API (paid, commented out)
- `textual`: TUI framework (Phase 4)

## Claude Code Skills

Custom skills for streamlined documentation, knowledge management, and session workflows. These are markdown instruction files in `.claude/skills/` that provide one-command workflows for common tasks.

### Available Skills

#### docs-update
**Purpose:** Automatically update all project documentation

**Usage:**
```bash
/docs-update
```
Or say: "Update the docs" or "Run docs update"

**What it does:**
- Updates `.STATUS` with latest progress
- Marks completed tasks in phase plans
- Recalculates metrics (LOC, tests, coverage)
- Checks for documentation inconsistencies
- Updates version numbers

#### session-wrap
**Purpose:** Generate brief, ADHD-friendly session summaries

**Usage:**
```bash
/session-wrap
```
Or say: "Wrap up" or "Summarize session"

**What it does:**
- Lists completed tasks
- Shows files created/modified
- Highlights key decisions
- Notes next steps
- Saves to `.claude/sessions/YYYY-MM-DD_HHMM.md`

**Output format:**
```markdown
# Session: 2025-12-13 14:30

## Completed
- âœ… Task 1
- âœ… Task 2

## Files
- Created: file1.py (100 lines)
- Modified: file2.md

## Next
â†’ Next task
```

#### checkpoint
**Purpose:** Complete checkpoint (docs + wrap + commit)

**Usage:**
```bash
/checkpoint
```
Or say: "Checkpoint" or "Save my work"

**What it does:**
1. Runs `docs-update` skill
2. Runs `session-wrap` skill
3. Stages all changes with `git add`
4. Creates commit with smart message
5. Optionally creates git tag

**Options:**
- `"Checkpoint: Custom message"` - Use custom commit message
- `"Checkpoint and tag as v2.1.0"` - Create tag
- `"Quick checkpoint"` - Skip docs update (WIP commits)

### Typical Workflow

```bash
# During development
# ... implement feature ...

# Save progress (WIP)
"Quick checkpoint"

# ... continue work ...

# Feature complete
"Checkpoint"

# Review summary
cat .claude/sessions/2025-12-13_1700.md

# Push if ready
git push origin main
```

### ADHD-Friendly Design

All skills follow these principles:
- âœ… One command does everything (no multi-step processes)
- âœ… Clear visual feedback (emojis, progress indicators)
- âœ… Automatic tracking (no manual note-taking required)
- âœ… Smart defaults (minimal decisions needed)
- âœ… Brief summaries (scannable, actionable output)
- âœ… Always show next steps (never wonder "what now?")

### Documentation

See `.claude/skills/README.md` for complete usage guide and examples.

## Troubleshooting

### Python CLI Not Found
- Check that `src/python/obs_cli.py` exists
- Verify file is executable: `chmod +x src/python/obs_cli.py`
- Run from project root directory

### Database Errors
- Initialize database: `python3 src/python/obs_cli.py db init`
- Check permissions on `~/.config/obs/`
- Verify SQLite3 is installed

### Import Errors
- Install dependencies: `pip3 install -r src/python/requirements.txt`
- Check Python version: `python3 --version` (must be 3.9+)

### Link Resolution Issues
- Verify wikilinks are in standard format: `[[target]]` or `[[target|display]]`
- Check for relative path issues
- Review broken links: `obs stats <vault_id>`

## Performance Considerations

### Database Optimization
- Indexes are created automatically via schema
- Use `VACUUM` periodically to reclaim space
- Consider `ANALYZE` for query optimization

### Scanning Large Vaults
- Use `--verbose` to monitor progress
- Scanner processes ~100 notes/second
- Graph metrics calculation is O(nÂ²) for centrality

### Memory Usage
- NetworkX graphs held in memory during analysis
- Large vaults (>10k notes) may need 1-2GB RAM
- Consider batch processing for very large vaults

## Security and Privacy

### Local-First Design
- All data stored locally in SQLite
- No data sent to cloud by default
- AI features use local models (100% private)

### AI Privacy (Phase 2)
- **Default providers are 100% local** (HuggingFace, Ollama)
- No API keys required for default setup
- No data sent to external servers
- Models run on your machine
- Complete privacy and offline capability

### API Key Management (Optional)
- Paid APIs (Claude, Gemini) are **optional** and commented out
- If using paid APIs, store keys in environment variables
- Never commit API keys to git
- Use `.env` file for local development

## Version History

- **2.0.0-beta** (2025-12-15):
  - Phase 1: Foundation, scanning, graph analysis (COMPLETE)
  - Phase 2: Free AI integration (HuggingFace + Ollama) (COMPLETE)
  - Phase 4: TUI/Visualization (IN PROGRESS)
    - Phase 4.1: TUI Foundation with Textual framework (COMPLETE)
    - Phase 4.2: Vault Browser with real database integration (COMPLETE)
    - Phase 4.3: Note Explorer with search and preview (COMPLETE)
    - Phase 4.4: Graph Visualizer (NEXT)
  - Claude Code Skills for docs/knowledge/wrap-up workflow
  - Interactive setup wizard with auto-detection
  - Complete test suite (122 tests, 70% coverage)
  - Comprehensive documentation
  - Note explorer: 378 lines, two-panel layout, real-time search, content preview
- **1.1.0** (2025-12-11): Quick wins - list, stats, unlink, completion
- **1.0.0** (2025-12-10): Initial release - vault management, R-Dev integration
